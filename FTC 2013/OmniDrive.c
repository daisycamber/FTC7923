#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     IRSEEKER2,      sensorNone)
#pragma config(Sensor, S4,     GYRO,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     m2,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     m3,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     m1,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     empty,         tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

// Set this to another value if you want the motors to peak at a different top speed
#define MAXMOTORSPEED 100
#define minvalue 3

// Turn offset
#define offset 0

// Current heading of the robot
float currHeading = 0;

int gyroOffset = 0;


// Task to keep track of the current heading using the HT Gyro
task getHeading () {
	float delTime = 0;
	float prevHeading = 0;
	float curRate = 0;

	PlaySound(soundBeepBeep);
wait1Msec(100);
gyroOffset = sensorValue[GYRO];

  wait1Msec(1000);
  while (true) {
    time1[T1] = 0;
    curRate = SensorValue[GYRO] - gyroOffset;
    if (abs(curRate) > 3) {
      prevHeading = currHeading;
      currHeading = prevHeading + curRate * delTime;
      if (currHeading > 360) currHeading -= 360;
      else if (currHeading < 0) currHeading += 360;
    }
    wait1Msec(5);
    delTime = ((float)time1[T1]) / 1000;
    //delTime /= 1000;
  }
}

// The angles that the motors are at
#define aWheel1 0.0
#define aWheel2 126.87
#define aWheel3 233.13

/*
For any given wheel, the speed it needs to turn at is :
Vw = Vb (cos Aw * cos At + sin Aw * sin At)

Vw = speed of the wheel
Vb = speed of the robot's body
Aw = the angle of the wheel on the body
At = the angle at which the body is travelling
*/

// Move the robot at the angle specified using speed as the base speed.
// rotSpeed specifies the amount of rotation the robot body should have (thus the turn
void moveRobot(int angle, int speed, int rotSpeed) {
  float Vw1, Vw2, Vw3, norm_factor;

  rotSpeed+=offset;

  // Adjust the angle to make it more intuitive
  angle-=90;

  // Calculate the individual motor speeds
  Vw1 = rotSpeed + speed * cosDegrees(angle);
  Vw2 = rotSpeed + speed * (-0.6 * cosDegrees(angle) + 0.8 * sinDegrees(angle));
  Vw3 = (rotSpeed + speed * (-0.6 * cosDegrees(angle) - 0.8 * sinDegrees(angle))) * -1;

  // This normalises all of the values to make sure
  // no motor value peaks over 100%
  if (Vw1 > MAXMOTORSPEED) {
    norm_factor = MAXMOTORSPEED / Vw1;
  } else if (Vw2 > MAXMOTORSPEED) {
    norm_factor = MAXMOTORSPEED / Vw2;
  } else if (Vw3 > MAXMOTORSPEED) {
    norm_factor = MAXMOTORSPEED / Vw3;
  } else {
    norm_factor = 1.0;
  }

  // Power the motors.
  motor[m1] = Vw1 * norm_factor;
  motor[m2] = Vw2 * norm_factor;
  motor[m3] = Vw3 * norm_factor;
}


// Get the speed for a given x and y
int getSpeed(int x, int y)
{
	if(abs(x) < minvalue && abs(y) < minvalue)
	{
		//writeDebugStreamLine("Ignoring low value");
		return 0;
	}
	return sqrt(((x*x) + (y*y))) * .8;
}


// Get an angle for the given x and y
int getAngle(int nx, int ny)
{
	float x = nx;
	float y = ny;

	if(abs(x) < minvalue && abs(y) < minvalue)
	{
		return 0;
	}

	// 1st quadrant
	if(x >= 0 && y >= 0)
	{
		//writeDebugStreamLine("First quadrant");
		int angle = 90 - (atan((y/x)) * 180 / PI);
		return angle;
	}
	// 2nd quadrant
	if(x >= 0 && y <= 0)
	{
		//writeDebugStreamLine("Second quadrant");
		int angle = 90 + (atan((abs(y)/x)) * 180 / PI);
		return angle;
	}
	// 3rd quadrant abs(y)/abs(x))) * 180 / PI;
	if(x <= 0 && y <= 0)
	{
	  int angle = 270 - (atan((abs(y)/abs(x))) * 180 / PI);
		return angle;
	}
	// 4th quadrant
	if(x <= 0 && y >= 0)
	{
		//writeDebugStreamLine("Fourth quadrant");
		int angle = 270 +(atan((y/abs(x))) * 180 / PI);
		return angle;
	}


	return 0;
}

task main () {
	//motor[m1] = 100;
	//motor[m2] = 100;
	//motor[m3] = 100;
	//moveRobot(0, 100, 0);
	//wait1Msec(500);
	//moveRobot(0, 0, 0);

	//wait1Msec(2000);
  //moveRobot(0, 0, 0);

	startTask(getHeading);
	wait1Msec(2000);

	while(true)
	{

		getJoystickSettings(joystick);
		//clearDebugStream();
		int angle = (getAngle(joystick.joy1_x1 * -1,joystick.joy1_y1) + 180) % 360;
		//angle = (angle + 90) % 360;
		int speed = getSpeed(joystick.joy1_x1,joystick.joy1_y1);
		int turn = joystick.joy1_x2 * -1;
		turn = turn / 2;
		if(speed < 7)
			speed = 0;

		if(abs(turn) < 7)
			turn = 0;

		nxtDisplayCenteredTextLine(4, "%f", currHeading);
		nxtDisplayCenteredTextLine(5, "%f", sensorValue[GYRO]);
		//writeDebugStream("Heading is %d \n", currHeading);
		//writeDebugStreamLine("@ %d degrees.", getAngle(joystick.joy1_x1, joystick.joy1_y1));

		turn = currHeading - 180;
		turn = turn * 2;

		moveRobot(angle,speed,turn);
		wait1Msec(100);
	}

}
