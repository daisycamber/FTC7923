#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     controllers,    sensorI2CMuxController)
#pragma config(Sensor, S2,     sensormultiplexer, sensorNone)
#pragma config(Sensor, S3,     touchmux1,      sensorHiTechnicTouchMux)
#pragma config(Sensor, S4,     HTSPB,          sensorI2CCustom9V)
#pragma config(Motor,  mtr_S1_C2_1,     flicker1,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift1,         tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     right,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     lift2,         tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    holder1,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    holder2,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-superpro.h"

#define BIT1O 1
#define BIT2O 2
#define BIT3O 4
#define BIT4O 8
#define BIT5O 16
#define BIT6O 32
#define BIT7O 64
#define BIT8O 128

#define BIT1A 254
#define BIT2A 253
#define BIT3A 251
#define BIT4A 247
#define BIT5A 239
#define BIT6A 223
#define BIT7A 191
#define BIT8A 127

#define HIGH true
#define LOW false
#define INPUT false
#define OUTPUT true

byte mode = 0;
byte output = 0;

void pinMode(byte pin, bool newMode)
{
	switch (pin)
	{
		case 0:
		if(newMode)
			mode = mode | BIT1O;
		else
			mode = mode & BIT1A;
		break;

		case 1:
		if(newMode)
			mode = mode | BIT2O;
		else
			mode = mode & BIT2A;
		break;

		case 2:
		if(newMode)
			mode = mode | BIT3O;
		else
			mode = mode & BIT3A;
		break;

		case 3:
		if(newMode)
			mode = mode | BIT4O;
		else
			mode = mode & BIT4A;
		break;

		case 4:
		if(newMode)
			mode = mode | BIT5O;
		else
			mode = mode & BIT5A;
		break;

		case 5:
		if(newMode)
			mode = mode | BIT6O;
		else
			mode = mode & BIT6A;
		break;

		case 6:
		if(newMode)
			mode = mode | BIT7O;
		else
			mode = mode & BIT7A;
		break;

		case 7:
		if(newMode)
			mode = mode | BIT8O;
		else
			mode = mode & BIT8A;
		break;

	}
	HTSPBsetupIO(HTSPB, mode);
}

void digitalWrite(byte pin, bool newMode)
{
	switch (pin)
	{
		case 0:
		if(newMode)
			output = output | BIT1O;
		else
			output = output & BIT1A;
		break;

		case 1:
		if(newMode)
			output = output | BIT2O;
		else
			output = output & BIT2A;
		break;

		case 2:
		if(newMode)
			output = output | BIT3O;
		else
			output = output & BIT3A;
		break;

		case 3:
		if(newMode)
			output = output | BIT4O;
		else
			output = output & BIT4A;
		break;

		case 4:
		if(newMode)
			output = output | BIT5O;
		else
			output = output & BIT5A;
		break;

		case 5:
		if(newMode)
			output = output | BIT6O;
		else
			output = output & BIT6A;
		break;

		case 6:
		if(newMode)
			output = output | BIT7O;
		else
			output = output & BIT7A;
		break;

		case 7:
		if(newMode)
			output = output | BIT8O;
		else
			output = output & BIT8A;
		break;

	}
	HTSPBwriteIO(HTSPB, output);
}



task phoenix()
{
	// Setup pins
	pinMode(0, OUTPUT);
	pinMode(1, OUTPUT);
	// Switch the functionality off for a bit, just to let the microcontroller know that we are ready for
	// action, in the event that this happened directly after a restart.
	digitalWrite(0, LOW);
	wait1Msec(200);
	// Tell the microcontroller that we want the restart functionality to be on again
	digitalWrite(0, HIGH);
	bool last = false;
	while(nNxtButtonPressed != kExitButton)
	{
		if(last)
		{
			digitalWrite(1, HIGH);
		}
		else
		{
			digitalWrite(1, LOW);
		}
		last = !last;
		wait1Msec(100);
	}
	// Tell the microcontroller that we want the restart functionality to be off
	digitalWrite(0, LOW);
	digitalWrite(1, LOW);
	StopAllTasks();
}





// Simple mapping function
long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float currHeading = 0;
// Gyro sensor offset
int offset;
task getHeading () {
	float delTime = 0;
	float prevHeading = 0;
	float curRate = 0;
  while (true) {
    time1[T1] = 0;
    //curRate = SensorValue[GYRO] - offset;
    if (abs(curRate) > 3) {
      prevHeading = currHeading;
      currHeading = prevHeading + curRate * delTime;
      if (currHeading > 360) currHeading -= 360;
      else if (currHeading < 0) currHeading += 360;
    }
    wait1Msec(5);
    delTime = ((float)time1[T1]) / 1000;
  }
}




int getExtBatLevel()
{
	if(externalBatteryAvg > 9999)
  		return map(externalBatteryAvg,10000,13000,0,100);
  return 0;
}
int getIntBatLevel()
{
	return map(nAvgBatteryLevel,3000,9000,0,100); // min 3v
}


// Code for shift registers ////////////////////////////////////////////////////////////////////////////////
int SER_Pin = 2;   //pin 14 on the 75HC595
int RCLK_Pin = 3;  //pin 12 on the 75HC595
int SRCLK_Pin = 4; //pin 11 on the 75HC595

//How many of the shift registers - change this
#define number_of_74hc595s 4

//do not touch
#define numOfRegisterPins number_of_74hc595s * 8

bool registers[numOfRegisterPins];


//set all register pins to LOW
void clearRegisters(){
  for(int i = numOfRegisterPins - 1; i >=  0; i--){
     registers[i] = LOW;
  }
}


//Set and display registers
//Only call AFTER all values are set how you would like (slow otherwise)
void writeRegisters(){

  digitalWrite(RCLK_Pin, LOW);

  for(int i = numOfRegisterPins - 1; i >=  0; i--){
    digitalWrite(SRCLK_Pin, LOW);

    int val = registers[i];

    digitalWrite(SER_Pin, val);
    digitalWrite(SRCLK_Pin, HIGH);

  }
  digitalWrite(RCLK_Pin, HIGH);

}

//set an individual pin HIGH or LOW
void setRegisterPin(int index, int value){
  registers[index] = value;
}

// End shift register code //////////////////////////////////////////////////////////////////////////////////


void setup()
{
	writeDebugStream("Starting...");
	// Calculate offset
	//PlaySound(soundBeepBeep);
	wait1Msec(500);
	//offset = SensorValue[GYRO];
	//PlaySound(soundBeepBeep);
	// Start heading task
  StartTask(getHeading);





  // Preform phoenix setup
	StartTask(phoenix);
  nNxtExitClicks = 5;

  pinMode(SER_Pin, OUTPUT);
  pinMode(RCLK_Pin, OUTPUT);
  pinMode(SRCLK_Pin, OUTPUT);


  //reset all register pins
  clearRegisters();
  writeRegisters();

  bool lsd = false;
  for(int i = 0; i < numOfRegisterPins-1; i++)
  {
  	lsd = !lsd;
  registers[i] = lsd;
}
	writeRegisters();



}


int place = 1;
// 0 = fully down
// 1 = fully up

//Bit map definitions
#define mux_button1 0x01
#define mux_button2 0x02
#define mux_button3 0x04
#define mux_button4 0x08

task main()
{
	setup();

	nMotorEncoder[lift1] = 0;
	nMotorEncoder[lift2] = 0;
  //waitForStart();

	while(true)
	{
		getJoystickSettings(joystick);

		motor[left] = abs(joystick.joy1_y2) < 5 ? 0 : joystick.joy1_y2;
		motor[right] = abs(joystick.joy1_y1) < 5 ? 0 : joystick.joy1_y1;

		int power = 40;
		// For paddle
		if(joy1Btn(4))
		{

			motor(flicker1) = power;
			//motor(flicker2) = -1 * power;
		}
		else
		{
			motor(flicker1) = 0;
			//motor(flicker2) = 0;
		}

		// For gate
		if(joy1Btn(3))
		{

			servo(gate) = 140;
		}
		else
		{
			servo[gate] = 55;
		}

		if(joy1Btn(2))
		{

			servo(holder1) = 100;
			servo(holder2) = 255 - 100;
		}
		else
		{
			servo(holder1) = 220;
			servo(holder2) = 255 - 240;
		}

		int power1 = 60;// Needs to be a bit more
		int power2 = 60;
		//writeDebugStream("%d %d \n", nMotorEncoder[lift1], nMotorEncoder[lift2];
		/*wait1Msec(100);
		if(nMotorEncoder[lift1]  < nMotorEncoder[lift2])
		{

			power1 = 50;
			power2 = 100;
		}
		else
		{
			power1 = 100;
			power2 = 50;
		}*/


		// Down
		if(joy1Btn(5) == true)
		{
			if(!(SensorValue(touchmux1) & mux_button1))
				motor(lift1) = power1;
			else nMotorEncoder[lift1] = 0;
			if(!(SensorValue(touchmux1) & mux_button3))
				motor(lift2) = -1 * power2;
			else nMotorEncoder[lift2] = 0;
			//place = 1;
		}
		else if(joy1Btn(6) == true)
		{
			if(!(SensorValue(touchmux1) & mux_button2))
				motor(lift1) = -1 * power1;
			///else motor(lift1) = 0;
			if(!(SensorValue(touchmux1) & mux_button4))
				motor(lift2) = power2;
			//else motor(lift2) = 0;
		}
		else
		{
			motor(lift1) = 0;
			motor(lift2) = 0;
		}

		// Place is desired position
		// Lift2 is slower
		// For lift up
		/*if(place == 1 && !(SensorValue(touchmux1) & mux_button1))
			motor(lift1) = 50;
		else if(place == 0 && )
			motor(lift1) = -50;
		else
			motor(lift1) = 0;

		if(place == 1 && !(SensorValue(touchmux1) & mux_button3))
			motor(lift2) = -60;
		else if(place == 0 && )
			motor(lift2) = 60;
		else
			motor(lift2) = 0;*/



	}

}
